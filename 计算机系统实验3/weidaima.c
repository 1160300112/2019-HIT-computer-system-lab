/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
__int64 sub_401020();
// char *getenv(const char *name);
// int *__errno_location(void);
// char *strcpy(char *dest, const char *src);
// int puts(const char *s);
// ssize_t write(int fd, const void *buf, size_t n);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// char *fgets(char *s, int n, FILE *stream);
// __sighandler_t signal(int sig, __sighandler_t handler);
// struct hostent *gethostbyname(const char *name);
// __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 strtol(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// int fflush(FILE *stream);
// __int64 __fastcall __isoc99_sscanf(_QWORD, _QWORD, _QWORD, _QWORD);
// __int64 __fastcall __printf_chk(_QWORD, _QWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// void __noreturn exit(int status);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// unsigned int sleep(unsigned int seconds);
// const unsigned __int16 **__ctype_b_loc(void);
// __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int socket(int domain, int type, int protocol);
FILE **deregister_tm_clones();
__int64 register_tm_clones();
FILE **_do_global_dtors_aux();
int __cdecl main(int argc, const char **argv, const char **envp);
void __fastcall phase_1(char *input);
void __fastcall phase_2(char *input);
void __fastcall phase_3(char *input);
int __fastcall func4(int n, int base);
void __fastcall phase_4(char *input);
void __fastcall phase_5(char *input);
void __fastcall phase_6(char *input);
int __fastcall fun7(treeNode *node, int val);
void __cdecl secret_phase();
void __fastcall sig_handler(int sig);
void __fastcall invalid_phase(char *s);
int __fastcall string_length(char *aString);
int __fastcall strings_not_equal(char *string1, char *string2);
void __cdecl initialize_bomb();
int __fastcall blank_line(char *str);
char *__cdecl skip();
void __cdecl __noreturn explode_bomb();
void __fastcall read_six_numbers(char *input, int *numbers);
char *__cdecl read_line();
void __cdecl phase_defused();
void __fastcall rio_readinitb(rio_t *rp, int fd);
void __fastcall sigalrm_handler(int sig);
ssize_t __fastcall rio_writen(int fd, void *usrbuf, size_t n);
int __fastcall urlencode(unsigned __int8 *src, unsigned __int8 *dst);
ssize_t __fastcall rio_read(rio_t *rp, char *usrbuf, size_t n);
ssize_t __fastcall rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
int __fastcall submitr(char *hostname, int port, char *course, char *userid, char *lab, char *result, char *status_msg);
void __fastcall init_timeout(int timeout);
int __fastcall init_driver(char *status_msg);
int __fastcall driver_post(char *userid, char *result, int autograded, char *status_msg);
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int array_3511[16] = { 2, 10, 6, 1, 12, 16, 9, 3, 4, 7, 14, 5, 11, 8, 15, 13 }; // idb
_UNKNOWN unk_403343; // weak
__int64 (__fastcall *_frame_dummy_init_array_entry)() = &frame_dummy; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)() = &_do_global_dtors_aux; // weak
__int64 (*qword_405010)(void) = NULL; // weak
treeNode n1 = { 36, &n21, &n22 }; // idb
listNode node1 = { 699, 1, &node2 }; // idb
FILE *_bss_start; // idb
__int64 stdin; // weak
__int64 stderr; // weak
char completed_7963; // weak
int num_input_strings; // idb
FILE *infile; // idb
char input_strings[1600]; // idb


//----- (0000000000401000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 405EE8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000401020) ----------------------------------------------------
__int64 sub_401020()
{
  return qword_405010();
}
// 405010: using guessed type __int64 (*qword_405010)(void);

//----- (00000000004011C0) ----------------------------------------------------
#error "4011C6: positive sp value has been found (funcsize=3)"

//----- (0000000000401200) ----------------------------------------------------
FILE **deregister_tm_clones()
{
  FILE **result; // rax

  result = &_bss_start;
  if ( &_bss_start != &_bss_start )
    result = 0LL;
  return result;
}

//----- (0000000000401230) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}

//----- (0000000000401270) ----------------------------------------------------
FILE **_do_global_dtors_aux()
{
  FILE **result; // rax

  if ( !completed_7963 )
  {
    result = deregister_tm_clones();
    completed_7963 = 1;
  }
  return result;
}
// 405768: using guessed type char completed_7963;

//----- (00000000004012A2) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  char *v4; // rax
  char *v5; // rax
  char *v6; // rax
  char *v7; // rax
  char *v8; // rax
  const char *v10; // rcx
  const char *v11; // rdx
  const char *v12; // rdx

  if ( argc == 1 )
  {
    infile = (FILE *)stdin;
  }
  else
  {
    if ( argc != 2 )
    {
      v12 = *argv;
      __printf_chk(1LL, "Usage: %s [<input_file>]\n");
      exit(8);
    }
    infile = fopen(argv[1], "r");
    if ( !infile )
    {
      v10 = argv[1];
      v11 = *argv;
      __printf_chk(1LL, "%s: Error: Couldn't open %s\n");
      exit(8);
    }
  }
  initialize_bomb();
  puts("Welcome to my fiendish little bomb. You have 6 phases with");
  puts("which to blow yourself up. Have a nice day!");
  v3 = read_line();
  phase_1(v3);
  phase_defused();
  puts("Phase 1 defused. How about the next one?");
  v4 = read_line();
  phase_2(v4);
  phase_defused();
  puts("That's number 2.  Keep going!");
  v5 = read_line();
  phase_3(v5);
  phase_defused();
  puts("Halfway there!");
  v6 = read_line();
  phase_4(v6);
  phase_defused();
  puts("So you got that one.  Try this one.");
  v7 = read_line();
  phase_5(v7);
  phase_defused();
  puts("Good work!  On to the next...");
  v8 = read_line();
  phase_6(v8);
  phase_defused();
  return 0;
}
// 401130: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD);
// 405750: using guessed type __int64 stdin;

//----- (00000000004013F5) ----------------------------------------------------
void __fastcall phase_1(char *input)
{
  if ( strings_not_equal(input, "The moon unit will be divided into two divisions.") )
    explode_bomb();
}

//----- (0000000000401410) ----------------------------------------------------
void __fastcall phase_2(char *input)
{
  signed int i; // ebx
  int numbers[6]; // [rsp+0h] [rbp-30h]

  read_six_numbers(input, numbers);
  if ( numbers[0] < 0 )
    explode_bomb();
  for ( i = 1; i <= 5; ++i )
  {
    if ( numbers[i] != numbers[i - 1] + i )
      explode_bomb();
  }
}

//----- (0000000000401461) ----------------------------------------------------
void __fastcall phase_3(char *input)
{
  signed int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int sum; // [rsp+8h] [rbp-8h]
  int index; // [rsp+Ch] [rbp-4h]

  if ( (signed int)__isoc99_sscanf(input, "%d %d", &index, &sum) <= 1 )
    explode_bomb();
  switch ( index )
  {
    case 0:
      v1 = 165;
      goto LABEL_6;
    case 1:
      v1 = 0;
LABEL_6:
      v2 = v1 - 103;
      goto LABEL_7;
    case 2:
      v2 = 0;
LABEL_7:
      v3 = v2 + 518;
      goto LABEL_8;
    case 3:
      v3 = 0;
LABEL_8:
      v4 = v3 - 709;
      goto LABEL_9;
    case 4:
      v4 = 0;
LABEL_9:
      v5 = v4 + 709;
      goto LABEL_10;
    case 5:
      v5 = 0;
LABEL_10:
      v6 = v5 - 709;
      goto LABEL_11;
    case 6:
      v6 = 0;
LABEL_11:
      v7 = v6 + 709;
      break;
    case 7:
      v7 = 0;
      break;
    default:
      explode_bomb();
      return;
  }
  v8 = v7 - 709;
  if ( index > 5 || sum != v8 )
    explode_bomb();
}

//----- (0000000000401511) ----------------------------------------------------
int __fastcall func4(int n, int base)
{
  int v2; // er13

  if ( n <= 0 )
    return 0;
  if ( n == 1 )
    return base;
  v2 = func4(n - 1, base) + base;
  return v2 + func4(n - 2, base);
}

//----- (000000000040155B) ----------------------------------------------------
void __fastcall phase_4(char *input)
{
  int v1; // eax
  int val; // [rsp+8h] [rbp-8h]
  int base; // [rsp+Ch] [rbp-4h]

  if ( (unsigned int)__isoc99_sscanf(input, "%d %d", &val, &base) != 2 || base <= 1 || base > 4 )
    explode_bomb();
  v1 = func4(9, base);
  if ( val != v1 )
    explode_bomb();
}

//----- (00000000004015AC) ----------------------------------------------------
void __fastcall phase_5(char *input)
{
  int v1; // ecx
  signed int i; // eax

  if ( string_length(input) != 6 )
    explode_bomb();
  v1 = 0;
  for ( i = 0; i <= 5; ++i )
    v1 += array_3511[input[i] & 0xF];
  if ( v1 != 60 )
    explode_bomb();
}

//----- (0000000000401601) ----------------------------------------------------
void __fastcall phase_6(char *input)
{
  signed int i; // er12
  int j; // ebx
  signed int k; // eax
  signed int l; // esi
  int v5; // eax
  listNode *v6; // rdx
  listNode *v7; // rbx
  listNode *v8; // rcx
  signed int v9; // eax
  listNode *v10; // rdx
  signed int m; // er12
  listNode *pointers[6]; // [rsp+0h] [rbp-70h]
  int indices[6]; // [rsp+30h] [rbp-40h]

  read_six_numbers(input, indices);
  for ( i = 0; i <= 5; ++i )
  {
    if ( (unsigned int)(indices[i] - 1) > 5 )
      explode_bomb();
    for ( j = i + 1; j <= 5; ++j )
    {
      if ( indices[i] == indices[j] )
        explode_bomb();
    }
  }
  for ( k = 0; k <= 5; ++k )
    indices[k] = 7 - indices[k];
  for ( l = 0; l <= 5; ++l )
  {
    v5 = 1;
    v6 = &node1;
    while ( indices[l] > v5 )
    {
      v6 = v6->next;
      ++v5;
    }
    pointers[l] = v6;
  }
  v7 = pointers[0];
  v8 = pointers[0];
  v9 = 1;
  while ( v9 <= 5 )
  {
    v10 = pointers[v9];
    v8->next = v10;
    ++v9;
    v8 = v10;
  }
  v8->next = 0LL;
  for ( m = 0; m <= 4; ++m )
  {
    if ( v7->value < v7->next->value )
      explode_bomb();
    v7 = v7->next;
  }
}

//----- (0000000000401715) ----------------------------------------------------
int __fastcall fun7(treeNode *node, int val)
{
  if ( !node )
    return -1;
  if ( node->value > val )
    return 2 * fun7(node->left, val);
  if ( node->value == val )
    return 0;
  return 2 * fun7(node->right, val) + 1;
}

//----- (000000000040174F) ----------------------------------------------------
void __cdecl secret_phase()
{
  char *v0; // rax
  int v1; // ebx

  v0 = read_line();
  v1 = strtol(v0, 0LL, 10);
  if ( (unsigned int)(v1 - 1) > 0x3E8 )
    explode_bomb();
  if ( fun7(&n1, v1) )
    explode_bomb();
  puts("Wow! You've defused the secret stage!");
  phase_defused();
}

//----- (00000000004017B0) ----------------------------------------------------
void __fastcall __noreturn sig_handler(int sig)
{
  puts("So you think you can stop the bomb with ctrl-c, do you?");
  sleep(3u);
  __printf_chk(1LL, "Well...");
  fflush(_bss_start);
  sleep(1u);
  puts("OK. :-)");
  exit(16);
}
// 401130: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD);

//----- (0000000000401806) ----------------------------------------------------
void __fastcall __noreturn invalid_phase(char *s)
{
  __printf_chk(1LL, "Invalid phase%s\n");
  exit(8);
}
// 401130: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD);

//----- (000000000040182B) ----------------------------------------------------
int __fastcall string_length(char *aString)
{
  int result; // eax

  result = 0;
  while ( *aString )
  {
    ++aString;
    ++result;
  }
  return result;
}

//----- (000000000040183F) ----------------------------------------------------
int __fastcall strings_not_equal(char *string1, char *string2)
{
  char *v2; // rbx
  char *v3; // r12
  int v4; // er13

  v2 = string1;
  v3 = string2;
  v4 = string_length(string1);
  if ( v4 != string_length(string2) )
    return 1;
  while ( 1 )
  {
    if ( !*v2 )
      return 0;
    if ( *v3 != *v2 )
      break;
    ++v2;
    ++v3;
  }
  return 1;
}

//----- (000000000040189C) ----------------------------------------------------
void __cdecl initialize_bomb()
{
  signal(2, (__sighandler_t)sig_handler);
}

//----- (00000000004018B2) ----------------------------------------------------
int __fastcall blank_line(char *str)
{
  char *v1; // r12
  char v2; // bl

  v1 = str;
  while ( 1 )
  {
    v2 = *v1;
    if ( !*v1 )
      break;
    ++v1;
    if ( !((*__ctype_b_loc())[v2] & 0x2000) )
      return 0;
  }
  return 1;
}

//----- (00000000004018ED) ----------------------------------------------------
char *__cdecl skip()
{
  char *v0; // rax
  char *v1; // rbx

  do
  {
    v0 = fgets((char *)(80LL * num_input_strings + 4216704), 80, infile);
    v1 = v0;
  }
  while ( v0 && blank_line(v0) );
  return v1;
}

//----- (000000000040193E) ----------------------------------------------------
void __cdecl __noreturn explode_bomb()
{
  puts("\nBOOM!!!");
  puts("The bomb has blown up.");
  exit(8);
}

//----- (0000000000401960) ----------------------------------------------------
void __fastcall read_six_numbers(char *input, int *numbers)
{
  if ( (signed int)__isoc99_sscanf(input, &unk_403343, numbers, numbers + 1) <= 5 )
    explode_bomb();
}

//----- (000000000040199C) ----------------------------------------------------
char *__cdecl read_line()
{
  int v0; // esi
  const char *v1; // rdx
  unsigned __int64 v2; // kr08_8
  int v4; // eax
  signed __int64 v5; // rax

  if ( !skip() )
  {
    if ( infile == (FILE *)stdin )
    {
      puts("Error: Premature EOF on stdin");
      exit(8);
    }
    if ( getenv("GRADE_BOMB") )
      exit(0);
    infile = (FILE *)stdin;
    if ( !skip() )
    {
      puts("Error: Premature EOF on stdin");
      exit(0);
    }
  }
  v0 = num_input_strings;
  v1 = (const char *)(80LL * num_input_strings + 4216704);
  v2 = strlen(v1) + 1;
  if ( (signed int)v2 - 1 > 78 )
  {
    puts("Error: Input line too long");
    v4 = num_input_strings++;
    v5 = 80LL * v4;
    *(_QWORD *)&input_strings[v5] = 7164793191628679722LL;
    *(_QWORD *)(v5 + 4216712) = 11868310583211105LL;
    explode_bomb();
  }
  input_strings[80 * num_input_strings - 2 + (signed int)v2] = 0;
  num_input_strings = v0 + 1;
  return (char *)v1;
}
// 405750: using guessed type __int64 stdin;

//----- (0000000000401ACD) ----------------------------------------------------
void __cdecl phase_defused()
{
  __int64 v0; // rbp
  int tmp2; // [rsp+0h] [rbp-60h]
  int tmp1; // [rsp+4h] [rbp-5Ch]
  char passphrase[80]; // [rsp+8h] [rbp-58h]
  __int64 v4; // [rsp+58h] [rbp-8h]

  if ( num_input_strings == 6 )
  {
    v4 = v0;
    if ( (unsigned int)__isoc99_sscanf(4216944LL, "%d %d %s", &tmp1, &tmp2) == 3
      && !strings_not_equal(passphrase, "DrEvil") )
    {
      puts("Curses, you've found the secret phase!");
      puts("But finding it and solving it are quite different...");
      secret_phase();
    }
    puts("Congratulations! You've defused the bomb!");
  }
}
// 401ACD: could not find valid save-restore pair for rbp

//----- (0000000000401B42) ----------------------------------------------------
void __fastcall rio_readinitb(rio_t *rp, int fd)
{
  rp->rio_fd = fd;
  rp->rio_cnt = 0;
  rp->rio_bufptr = rp->rio_buf;
}

//----- (0000000000401B54) ----------------------------------------------------
void __fastcall __noreturn sigalrm_handler(int sig)
{
  __fprintf_chk(stderr, 1LL, "Program timed out after %d seconds\n", 0LL);
  exit(1);
}
// 401170: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 405760: using guessed type __int64 stderr;

//----- (0000000000401B82) ----------------------------------------------------
ssize_t __fastcall rio_writen(int fd, void *usrbuf, size_t n)
{
  char *v3; // r12
  size_t v4; // r14
  size_t v5; // rbx
  ssize_t v6; // rax

  v3 = (char *)usrbuf;
  v4 = n;
  v5 = n;
  while ( 1 )
  {
    if ( !v5 )
      return v4;
    v6 = write(fd, v3, v5);
    if ( v6 <= 0 )
      break;
LABEL_2:
    v5 -= v6;
    v3 += v6;
  }
  if ( *__errno_location() == 4 )
  {
    v6 = 0LL;
    goto LABEL_2;
  }
  return -1LL;
}

//----- (0000000000401BDF) ----------------------------------------------------
int __fastcall urlencode(unsigned __int8 *src, unsigned __int8 *dst)
{
  unsigned __int8 *v2; // rbx
  unsigned __int8 *v3; // r12
  int result; // eax
  int v5; // er13
  unsigned __int8 v6; // r8
  char buf[8]; // [rsp+8h] [rbp-28h]

  v2 = src;
  v3 = dst;
  for ( result = strlen((const char *)src); ; result = v5 )
  {
    v5 = result - 1;
    if ( !result )
      break;
    v6 = *v2;
    if ( v6 == 45
      || v6 == 42
      || v6 == 46
      || v6 == 95
      || (unsigned __int8)(v6 - 48) <= 9u
      || (unsigned __int8)(v6 - 65) <= 0x19u
      || (unsigned __int8)(v6 - 97) <= 0x19u )
    {
      *v3++ = v6;
    }
    else if ( v6 == 32 )
    {
      *v3++ = 43;
    }
    else
    {
      if ( v6 != 9 && (unsigned __int8)(v6 - 32) > 0x5Fu )
        return -1;
      __sprintf_chk(buf, 1LL, 8LL, "%%%02X", v6);
      *v3 = buf[0];
      v3[1] = buf[1];
      v3[2] = buf[2];
      v3 += 3;
    }
    ++v2;
  }
  return result;
}
// 4011A0: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401CDF) ----------------------------------------------------
ssize_t __fastcall rio_read(rio_t *rp, char *usrbuf, size_t n)
{
  size_t v3; // r13
  int v4; // er12
  int v5; // eax

  v3 = n;
  while ( 1 )
  {
    v4 = rp->rio_cnt;
    if ( v4 > 0 )
      break;
    v5 = read(rp->rio_fd, rp->rio_buf, 0x2000uLL);
    rp->rio_cnt = v5;
    if ( v5 < 0 )
    {
      if ( *__errno_location() != 4 )
        return -1LL;
    }
    else
    {
      if ( !v5 )
        return 0LL;
      rp->rio_bufptr = rp->rio_buf;
    }
  }
  if ( v4 >= v3 )
    v4 = v3;
  memcpy(usrbuf, rp->rio_bufptr, v4);
  rp->rio_bufptr += v4;
  rp->rio_cnt -= v4;
  return v4;
}

//----- (0000000000401D6B) ----------------------------------------------------
ssize_t __fastcall rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)
{
  _BYTE *v3; // r12
  size_t v4; // r13
  signed int v5; // ebx
  int v6; // eax
  char v7; // al
  char c; // [rsp+Fh] [rbp-21h]

  v3 = usrbuf;
  v4 = maxlen;
  v5 = 1;
  while ( 1 )
  {
    if ( v5 >= v4 )
      goto LABEL_10;
    v6 = rio_read(rp, &c, 1uLL);
    if ( v6 != 1 )
      break;
    v7 = c;
    *v3 = c;
    if ( v7 == 10 )
    {
      ++v3;
LABEL_10:
      *v3 = 0;
      return v5;
    }
    ++v5;
    ++v3;
  }
  if ( !v6 )
  {
    if ( v5 == 1 )
      return 0LL;
    goto LABEL_10;
  }
  return -1LL;
}

//----- (0000000000401DF0) ----------------------------------------------------
int __fastcall submitr(char *hostname, int port, char *course, char *userid, char *lab, char *result, char *status_msg)
{
  char *v7; // r15
  char *v8; // r14
  unsigned __int8 *v9; // r13
  int v10; // eax
  int v11; // ebx
  struct hostent *v12; // rax
  bool v13; // cf
  bool v14; // zf
  char *v15; // rsi
  const char *v16; // rdi
  signed __int64 v17; // rcx
  ssize_t v18; // rax
  int v19; // eax
  bool v20; // cf
  bool v21; // zf
  const char *v22; // rdi
  signed __int64 v23; // rcx
  char *v24; // rsi
  const char *coursea; // [rsp+18h] [rbp-A068h]
  int errcode; // [rsp+202Ch] [rbp-8054h]
  char version[8192]; // [rsp+2030h] [rbp-8050h]
  char enc_result[8192]; // [rsp+4030h] [rbp-6050h]
  char buf[8192]; // [rsp+6030h] [rbp-4050h]
  rio_t rio; // [rsp+8030h] [rbp-2050h]
  sockaddr_in serveraddr; // [rsp+A040h] [rbp-40h]

  coursea = course;
  v7 = userid;
  v8 = lab;
  v9 = (unsigned __int8 *)result;
  errcode = 0;
  v10 = socket(2, 1, 0);
  if ( v10 < 0 )
  {
    *(_QWORD *)status_msg = 4836930262966366789LL;
    *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
    *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
    *((_QWORD *)status_msg + 3) = 8295742064141103715LL;
    *((_DWORD *)status_msg + 8) = 1701536623;
    *((_WORD *)status_msg + 18) = 116;
    v19 = -1;
  }
  else
  {
    v11 = v10;
    v12 = gethostbyname(hostname);
    if ( v12 )
    {
      *(_QWORD *)&serveraddr.sin_port = 0LL;
      *(_DWORD *)&serveraddr.sin_zero[2] = 0;
      *(_WORD *)&serveraddr.sin_zero[6] = 0;
      serveraddr.sin_family = 2;
      __memmove_chk(&serveraddr.sin_addr, *v12->h_addr_list, v12->h_length, 12LL);
      serveraddr.sin_port = __ROL2__(port, 8);
      if ( connect(v11, (const struct sockaddr *)&serveraddr, 0x10u) < 0 )
      {
        *(_QWORD *)status_msg = 6133966955649069637LL;
        *((_QWORD *)status_msg + 1) = 8031079655490609518LL;
        *((_QWORD *)status_msg + 2) = 8386658456067597088LL;
        *((_QWORD *)status_msg + 3) = 2334386829831140384LL;
        *((_DWORD *)status_msg + 8) = 1987208563;
        *((_WORD *)status_msg + 18) = 29285;
        status_msg[38] = 0;
        close(v11);
        v19 = -1;
      }
      else if ( strlen(coursea) + 1 + strlen(v7) + 1 - 2 + strlen(v8) + 3 * (strlen((const char *)v9) + 1) - 3 + 128 > 0x2000 )
      {
        *(_QWORD *)status_msg = 5917794173535285829LL;
        *((_QWORD *)status_msg + 1) = 8391086215129297765LL;
        *((_QWORD *)status_msg + 2) = 8029764343147948402LL;
        *((_QWORD *)status_msg + 3) = 2318902353117408288LL;
        *((_QWORD *)status_msg + 4) = 7310293708491157065LL;
        *((_QWORD *)status_msg + 5) = 5932447205327983392LL;
        *((_QWORD *)status_msg + 6) = 19796991806623071LL;
        close(v11);
        v19 = -1;
      }
      else
      {
        memset(enc_result, 0, sizeof(enc_result));
        if ( urlencode(v9, (unsigned __int8 *)enc_result) < 0 )
        {
          *(_QWORD *)status_msg = 5917794173535285829LL;
          *((_QWORD *)status_msg + 1) = 8391086215129297765LL;
          *((_QWORD *)status_msg + 2) = 7957688057412348274LL;
          *((_QWORD *)status_msg + 3) = 7953674097058734452LL;
          *((_QWORD *)status_msg + 4) = 7809636914145552672LL;
          *((_QWORD *)status_msg + 5) = 8246212367049977632LL;
          *((_QWORD *)status_msg + 6) = 2334391151659085417LL;
          *((_QWORD *)status_msg + 7) = 7310577365311121507LL;
          *((_WORD *)status_msg + 32) = 11890;
          status_msg[66] = 0;
          close(v11);
          v19 = -1;
        }
        else
        {
          __sprintf_chk(
            buf,
            1LL,
            0x2000LL,
            "GET /%s/submitr.pl/?userid=%s&lab=%s&result=%s&submit=submit HTTP/1.0\r\n\r\n",
            coursea);
          if ( rio_writen(v11, buf, strlen(buf)) < 0 )
          {
            *(_QWORD *)status_msg = 4836930262966366789LL;
            *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
            *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
            *((_QWORD *)status_msg + 3) = 8031079655625290359LL;
            *((_QWORD *)status_msg + 4) = 8243121275949052960LL;
            *((_DWORD *)status_msg + 10) = 7497078;
            close(v11);
            v19 = -1;
          }
          else
          {
            rio_readinitb(&rio, v11);
            if ( rio_readlineb(&rio, buf, 0x2000uLL) <= 0 )
            {
              *(_QWORD *)status_msg = 4836930262966366789LL;
              *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
              *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
              *((_QWORD *)status_msg + 3) = 8244232882187494770LL;
              *((_QWORD *)status_msg + 4) = 7306071583668335731LL;
              *((_QWORD *)status_msg + 5) = 8295750839044546674LL;
              *((_DWORD *)status_msg + 12) = 1702261349;
              *((_WORD *)status_msg + 26) = 114;
              close(v11);
              v19 = -1;
            }
            else
            {
              __isoc99_sscanf(buf, "%s %d %[a-zA-z ]", version, &errcode);
              v13 = (unsigned int)errcode < 0xC8;
              v14 = errcode == 200;
              if ( errcode == 200 )
              {
                while ( 1 )
                {
                  v15 = buf;
                  v16 = "\r\n";
                  v17 = 3LL;
                  do
                  {
                    if ( !v17 )
                      break;
                    v13 = (unsigned __int8)*v15 < *v16;
                    v14 = *v15++ == *v16++;
                    --v17;
                  }
                  while ( v14 );
                  if ( (!v13 && !v14) == v13 )
                    break;
                  v18 = rio_readlineb(&rio, buf, 0x2000uLL);
                  v13 = 0;
                  v14 = v18 == 0;
                  if ( v18 <= 0 )
                  {
                    *(_QWORD *)status_msg = 4836930262966366789LL;
                    *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
                    *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
                    *((_QWORD *)status_msg + 3) = 7018130082659132786LL;
                    *((_QWORD *)status_msg + 4) = 8030593375116879204LL;
                    *((_QWORD *)status_msg + 5) = 8243124926671954029LL;
                    status_msg[48] = 0;
                    close(v11);
                    return -1;
                  }
                }
                if ( rio_readlineb(&rio, buf, 0x2000uLL) <= 0 )
                {
                  *(_QWORD *)status_msg = 4836930262966366789LL;
                  *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
                  *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
                  *((_QWORD *)status_msg + 3) = 7022364301937698162LL;
                  *((_QWORD *)status_msg + 4) = 8319104456053716340LL;
                  *((_QWORD *)status_msg + 5) = 7885647255504775009LL;
                  *((_QWORD *)status_msg + 6) = 32199706744812320LL;
                  close(v11);
                  v19 = -1;
                }
                else
                {
                  strcpy(status_msg, buf);
                  close(v11);
                  v22 = "OK";
                  v23 = 3LL;
                  v24 = status_msg;
                  do
                  {
                    if ( !v23 )
                      break;
                    v20 = (unsigned __int8)*v24 < *v22;
                    v21 = *v24++ == *v22++;
                    --v23;
                  }
                  while ( v21 );
                  v19 = (char)((!v20 && !v21) - v20);
                  if ( (!v20 && !v21) != v20 )
                    v19 = -1;
                }
              }
              else
              {
                __sprintf_chk(
                  status_msg,
                  1LL,
                  -1LL,
                  "Error: HTTP request failed with error %d: %s",
                  (unsigned int)errcode);
                close(v11);
                v19 = -1;
              }
            }
          }
        }
      }
    }
    else
    {
      *(_QWORD *)status_msg = 4908987857004294725LL;
      *((_QWORD *)status_msg + 1) = 7959303596504273742LL;
      *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
      *((_QWORD *)status_msg + 3) = 2334402189959849330LL;
      *((_QWORD *)status_msg + 4) = 6998719601038222707LL;
      *((_DWORD *)status_msg + 10) = 1701995620;
      *((_WORD *)status_msg + 22) = 29555;
      status_msg[46] = 0;
      close(v11);
      v19 = -1;
    }
  }
  return v19;
}
// 4010E0: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 4011A0: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402504) ----------------------------------------------------
void __fastcall init_timeout(int timeout)
{
  int v1; // ebx

  if ( timeout )
  {
    v1 = timeout;
    if ( timeout < 0 )
      v1 = 0;
    signal(14, (__sighandler_t)sigalrm_handler);
    alarm(v1);
  }
}

//----- (0000000000402539) ----------------------------------------------------
int __fastcall init_driver(char *status_msg)
{
  int v1; // eax
  int v2; // ebx
  struct hostent *v3; // rax
  int result; // eax
  sockaddr_in serveraddr; // [rsp+0h] [rbp-20h]

  signal(13, (__sighandler_t)1);
  signal(29, (__sighandler_t)1);
  signal(29, (__sighandler_t)1);
  v1 = socket(2, 1, 0);
  if ( v1 < 0 )
  {
    *(_QWORD *)status_msg = 4836930262966366789LL;
    *((_QWORD *)status_msg + 1) = 7959303600887654764LL;
    *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
    *((_QWORD *)status_msg + 3) = 8295742064141103715LL;
    *((_DWORD *)status_msg + 8) = 1701536623;
    *((_WORD *)status_msg + 18) = 116;
    result = -1;
  }
  else
  {
    v2 = v1;
    v3 = gethostbyname("127.0.0.1");
    if ( v3 )
    {
      *(_QWORD *)&serveraddr.sin_port = 0LL;
      *(_DWORD *)&serveraddr.sin_zero[2] = 0;
      *(_WORD *)&serveraddr.sin_zero[6] = 0;
      serveraddr.sin_family = 2;
      __memmove_chk(&serveraddr.sin_addr, *v3->h_addr_list, v3->h_length, 12LL);
      serveraddr.sin_port = 28219;
      if ( connect(v2, (const struct sockaddr *)&serveraddr, 0x10u) < 0 )
      {
        __sprintf_chk(status_msg, 1LL, -1LL, "Error: Unable to connect to server %s", "127.0.0.1");
        close(v2);
        result = -1;
      }
      else
      {
        close(v2);
        *(_WORD *)status_msg = 19279;
        status_msg[2] = 0;
        result = 0;
      }
    }
    else
    {
      *(_QWORD *)status_msg = 4908987857004294725LL;
      *((_QWORD *)status_msg + 1) = 7959303596504273742LL;
      *((_QWORD *)status_msg + 2) = 2337214414117954145LL;
      *((_QWORD *)status_msg + 3) = 2334402189959849330LL;
      *((_QWORD *)status_msg + 4) = 6998719601038222707LL;
      *((_DWORD *)status_msg + 10) = 1701995620;
      *((_WORD *)status_msg + 22) = 29555;
      status_msg[46] = 0;
      close(v2);
      result = -1;
    }
  }
  return result;
}
// 4010E0: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 4011A0: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402717) ----------------------------------------------------
int __fastcall driver_post(char *userid, char *result, int autograded, char *status_msg)
{
  char *v4; // rbx
  int v5; // eax

  v4 = status_msg;
  if ( autograded )
  {
    __printf_chk(1LL, "\nAUTORESULT_STRING=%s\n");
    *(_WORD *)v4 = 19279;
    v4[2] = 0;
    v5 = 0;
  }
  else if ( userid && *userid )
  {
    v5 = submitr("127.0.0.1", 15214, "csapp", userid, "HITICS2019", result, status_msg);
  }
  else
  {
    *(_WORD *)status_msg = 19279;
    status_msg[2] = 0;
    v5 = 0;
  }
  return v5;
}
// 401130: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD);

//----- (00000000004027A0) ----------------------------------------------------
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  init_proc();
  v4 = &_do_global_dtors_aux_fini_array_entry - &_frame_dummy_init_array_entry;
  if ( v4 )
  {
    v5 = 0LL;
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&_frame_dummy_init_array_entry + v5++))(a1, a2, v3);
    while ( v4 != v5 );
  }
}
// 404E10: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry)();
// 404E18: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)();

//----- (0000000000402804) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 39 function(s)"
